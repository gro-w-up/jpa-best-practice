## 항목 1: @OneToMany 연관관계를 효과적으로 구성하는 방법

### 항상 부모 측에서 자식 측으로 전이를 사용

```java
@OneToMany(cascade=CascadeType.ALL)
```

- 부모 객체가 변경되었을 때 자식 객체에도 해당 변경 사항을 전파할지 여부를 설정할 수 있습니다.
- `CascadeType.ALL` 은 다음과 같은 작업에 대해 전파됩니다.
    - `PERSIST`: 부모 객체가 영구 저장될 때 자식 객체도 함께 저장됩니다.
    - `REMOVE`: 부모 객체가 삭제될 때 자식 객체도 함께 삭제됩니다.
    - `REFRESH`: 부모 객체가 새로고침될 때 자식 객체도 함께 새로 고쳐집니다.
    - `MERGE`: 부모 객체가 병합될 때 자식 객체도 함께 병합됩니다.
    - `DETACH`: 부모 객체가 분리될 때 자식 객체도 함께 분리됩니다.

### 부모 측에 mappedBy지정

- mappedBy 속성은 양방향 연관관계의 특성을 부여한다.
- 부모측에는 @OneToMany mappedBy가 지정되고 mappedBy에 의해 참조되는 자식 측에는 @ManyToOne이 지정된다.
- mappedBy는 양방향 연관관계 매핑을 미러링한다는 신호를 보내는 것

```java
@OneToMany(cascade=CascadeType.ALL, mappedBy="author")
```

### 부모 측에 orphanRemoval 지정

- 더 이상 참조되지 않는 자식들의 삭제를 보장한다.
- 소유 객체로부터 참조 없이 존재할 수 없는 의존 객체를 정리하기에 유용하다.

```java
@OneToMany(cascade=CascadeType.ALL, mappedBy="author", orphanRemoval=true)
```

- 🤔 이건 참조를 끊을 때 데이터베이스에서 데이터를 지우게 되는데 현업에서는 사용하기 어려울 것 같다..?
물론 참조되지 않는 자식들이라면 서비스 운영에는 지장없겠지만 히스토리를 찾을 수 없기 때문에 사용하지 않을것이다..

### 연관관계의 양측을 동기화 상태로 유지

- 유지하지 않으면 객체의 상태 전환으로 인해 예기치 않은 동작이 발생될 수 있음으로 도우미 메소드를 통해 연관관계의 양쪽 상태를 동기화 한다.

### equals()와 hashCode() 오버라이딩

- 이거 오버라이딩하면 모든 엔티티가 상태 전환에서 동일한 결과를 얻을 수 있다. -동등성 검사
- 🤔 이건 대체 언제 써야하는걸까..?
동일한 이름과 이메일을 가진 두 사용자가 있을 때 이 두명이 동일한 사용자인지 확인 할 때 사용할 수 있을 것 같다.

### 연관관계 양측에서 지연 로딩 사용

- 부모 측 객체를 가지고 올 때 자식 측 객체는 가져오려면 자식 객체에서 명시적으로 LAZY로 지정하면 된다.

```java
@ManyToOne(fetch = FetchType.LAZY)
```

### toString() 오버라이딩 방법에 주의

- 부모 객체에서 자식 컬렉션을 사용하지 말고 부모 객체의 기본 속성만 사용해야한다.
- 이걸 지키지 않으면 자식의 데이터를 가져오는 별도 SQL문이 실행되거나 LazyInitailizationException이 발생되기 때문이다.

### @JoinColumn을 사용해 조인 컬럼 지정

- 조인 컬럼을 지정할 때 명시적으로 의도된 이름을 사용하는 것이 혼동이나 실수를 피할 수 있기 때문에 좋다.
- 이거 아무렇게나 짓는게 아니라 데이터베이스 내에서 연관관계를 가지는 부모 객체의 외래 키의 이름을 지정하는 거임!
- 한마디로 연관관계를 가지는 테이블 컬럼을 만들 때 외래 키는 명시적으로 의도된 이름을 사용해야 한다는 것

## 항목 2: 단방향 @OneToMany 연관관계를 피해야 하는 이유
- 이 항목에서 결론적으로 말하고자 하는 것은 양방향 연관관계를 가질 때 보다 처리해야하는 데이터들이 더 많아 효율적이지 않기 때문에 피해야한다고 말하고 있다.
- 연관관계를 가지는 테이블이 생성되어야하기 때문이다.

## 항목 3: 단방향 @ManyToOne 효율성
- 항목2와 반대로 이건 효율적이다.
- 🤔 '왜?' 일까?  
  양방향과 동일한 매커니즘으로 작동하며 항목 2에서 발생하는 비효율적인 연산을 하지 않기 때문이다.
  예시로 저자의 모든 도서를 가지고 오는 쿼리가 있다고 할 때 하나의 select만 필요하기 때문이다. 
  가져온 컬렉션에서 도서를 삭제하는 경우에도 하나의 delete문을 통해 삭제가 되기 때문이다. 양방향 @OneToMany 연관관계가 필요하지 않을 때 사용하면 될 듯 싶다.

## 항목 4: @ManyToMany 연관관계를 효율적으로 구성하는 방법
- ManyToMany는 양쪽 모두 부모 테이블임. 양쪽 모두 탐색할 수 있기 떄문. 둘다 부모이기 때문에 외래키를 보유하지 않아서 별도의 조인테이블을 가짐. 이 조인테이블이 자식 역할을 함.
### 관계의 오너 선택
- 한쪽만 오너가 될 수 있고 변경 사항은 오너로부터 전파됨. Author를 오너로 선택하면 반대쪽은 mappedBy가 추가된다.
### 항상 List가 아닌 Set 사용
- 특히 삭제 처리와 관련해 좋음.
### 연관관계의 양측 동기화 상태 유지
- 좀 더 많이 사용되는 쪽 즉, 코드로 따져보면 더 많이 접근하는 Repository의 Entity에 도우미 메서드인 추가, 삭제를 추가하는 것이 쉽게 동기화 상태를 유지할 수 있는 방법이다.
### CascadeType.ALL, REMOVE 사용하지 않기
- 왜 사용하지 말라고 하느냐? → 만약 도서가 여러 저자에 의해 공동저술 될 수 있는 경우이고 CascadeType.ALL로 설정되어 있는 경우 저자 엔티티를 삭제할 때 도서 데이터도 지워지기 때문임.
- 그럼 안전하게 ALL을 사용하지 말고 PERSIST, MERGE만 등록해놓고 필요하면 추가 등록하여 사용하는 것이 안전하겠다.
### 조인 테이블 설정
- 명시적으로 설정하여 혼동없이 정보를 참조할 수 있도록 한다.
### 연관관계 양측에서 지연 로딩 사용
- ManyToMany는 기본적으로 Lazy처리 되고 이 방식을 그대로 사용하여야함. → 당연하게도 양쪽 모두 탐색할 수 있어야 하기 때문임.
### equals 및 hashCode 오버라이딩
- 엔티티 상태 전환에서 항상 동일한 결과를 얻기 위해 오버라이딩 하여 객체 비교를 할 수 이씀.
### toString 주의
  - 해당 엔티티의 기본 속성만 포함되도록 설정, 만약 연관관계를 포함하게 된다면 해당 데이터를 가지고 오는 별도의 SQL문이 실행 되기 때문임.

## 항목 5: @ManyToMany에서 Set이 List보다 나은 이유
### List vs Set  
- 특히 삭제에서 나타남
- ManyToMany 관계를 사용하는 경우 하이버네이트에서는 연결테이블에 2개의 단반향 OneToMany관계로 처리하게 되는데 리스트를 사용하는 경우에는 연결테이블에 있는 모든 데이터를 지운 뒤 삭제할 데이터를 빼고 insert하게 되는 반면, Set을 사용하게 되면 삭제할 데이터만 삭제를 할 수 있음.
리스트를 사용하며는 경우 더 많은 연결 항목이 다시 등록될수록 데이터베이스 트랙잭션이 길어지기 때문에 Set보다 좋지 않다.

### 결과 세트 순서 유지  
- rrayList는 삽입된 요소의 순서를 유지 하고 HashSet은 그렇지 않다.
- JPA는 @OrderBy, @OrderColumn 2가지 방법으로 결과셋을 정렬하고 있다.
- HashSet과 OrderBy를 같이 사용하는 경우 Set의 순서가 유지되지만 비영속 상태에서 일관성이 없을 수 있다는 주의점이 있다. 비영속 상태에서도 일관성을 유지해야한다면 LinkedHashSet을 사용하는 편이 좋다.
